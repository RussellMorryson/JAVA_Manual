
Когда вы объявляете переменную или метод как статические, они 
принадлежат классу, а не конкретному экземпляру. Это означает, 
что существует только один экземпляр статического члена, даже если 
вы создаете несколько объектов класса или не создаете ни одного. Он 
будет общим для всех объектов.
Пример:

public class Counter {
  public static int COUNT=0;
  Counter() {
    COUNT++;
  }
}

Переменная COUNT будет общей для всех объектов этого класса.
Теперь мы можем создавать объекты нашего класса Counter в main и 
получать доступ к статической переменной.

public class Counter {
    public static int COUNT=0;
    Counter() {
        COUNT++;
    }
}

public class MyClass {
    public static void main(String[ ] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        System.out.println(Counter.COUNT);
    }
}

Результат равен 2, потому что переменная COUNT является статической и 
увеличивается на единицу каждый раз, когда создается новый объект 
класса Counter. В приведенном выше коде мы создали 2 объекта.
Вы также можете получить доступ к статической переменной, используя 
любой объект этого класса, например c1.COUNT.
Обычной практикой является использование верхнего регистра при 
именовании статической переменной, хотя это и не обязательно.

Та же концепция применима и к статическим методам.

public class Vehicle {
  public static void horn() {
    System.out.println("Beep");
  }
}

Теперь метод horn может быть вызван без создания объекта:

public class Vehicle {
    public static void horn() {
        System.out.println("Beep");
    }
}

public class MyClass {
    public static void main(String[ ] args) {
        Vehicle.horn();
    }
}

Другим примером статических методов являются методы класса Math, 
поэтому вы можете вызывать их без создания математического объекта.
Кроме того, основной метод всегда должен быть статическим.

=====================================================================================
FINAL
Используйте ключевое слово final, чтобы пометить переменную константой, 
чтобы ее можно было назначить только один раз.
Пример:

class MyClass {
    public static final double PI = 3.14; 
    public static void main(String[ ] args) {
        System.out.println(PI);
    }
}

=====================================================================================
Пакеты
Пакеты используются для того, чтобы избежать конфликтов имен и 
контролировать доступ к классам.

Пакет может быть определен как группа, состоящая из аналогичных 
типов классов, наряду с подпакетами.

Создать пакет на Java довольно просто. Просто щелкните правой 
кнопкой мыши на вашем каталоге src и выберите Создать-> Пакет. 
Дайте вашему пакету имя и нажмите Готово.

Вы заметите, что новый пакет появится в каталоге проекта. Теперь 
вы можете перемещать и создавать классы внутри этого пакета. 
Мы перенесли наши классы транспортных средств, прилавков и 
животных в образцы упаковки.

Когда вы перемещаете/создаете класс в своем пакете, следующий 
код появится в верхней части списка файлов.

package samples;

Это указывает на пакет, к которому принадлежит класс.
Теперь нам нужно импортировать классы, которые находятся 
внутри пакета, в наш основной, чтобы иметь возможность их 
использовать.

В следующем примере показано, как использовать класс 
транспортного средства пакета samples.

import samples.Vehicle;

class MyClass {
  public static void main(String[ ] args) {
    Vehicle v1 = new Vehicle();
    v1.horn();
  }
}

Два основных результата возникают, когда класс 
помещается в пакет. Во-первых, имя пакета становится 
частью имени класса. Во-вторых, имя пакета должно 
соответствовать структуре каталогов, в которой 
находится соответствующий файл класса.

Используйте подстановочный знак для импорта всех классов в пакете.
Например, import samples.* импортирует все классы в пакете samples.

*****************************************************************************
"default" access in Java is "package-private", meaning that everything 
in the same package can access the attribute/method. So basically 
this should also be correct! Even "protected" (the missing level 
of accessibility) would the correct, even though it is not in the 
set of possible answers - it means "accessible from the same class 
and from all is subclasses", which is obviously more than "the same 
class".

доступ "по умолчанию" в Java - "package-private", что означает, 
что все в одном пакете могут получить доступ к атрибуту /методу. 
Так что в принципе это тоже должно быть правильно! 
Даже "защищенный" (отсутствующий уровень доступности) 
был бы правильным, даже если его нет в наборе возможных
ответов - это означает "доступный из того же класса и из 
всех подклассов is", что, очевидно, больше, чем "тот же класс".
************************************************************************
=====================================================================================
Encapsulation - инкапсуляция

В ООП существует 4 основных понятия: 
инкапсуляция, 
наследование, 
полиморфизм 
и абстракция.

Идея инкапсуляции заключается в том, чтобы гарантировать, что детали реализации 
не будут видны пользователям. Переменные одного класса будут скрыты от 
других классов, доступные только через методы текущего класса. 
Это называется скрытием данных.

Чтобы достичь инкапсуляции в Java, объявите переменные класса как 
частные и предоставьте общедоступные методы setter и getter для изменения 
и просмотра значений переменных.

Например:

class BankAccount {
  private double balance=0;
  public void deposit(double x) {
    if(x > 0) {
      balance += x;
    }
  }
}

Эта реализация скрывает переменную баланса, предоставляя доступ к 
ней только через метод депозита, который проверяет сумму, подлежащую 
внесению, перед изменением переменной.

Таким образом, инкапсуляция обеспечивает следующие преимущества:
- Контроль способа доступа к данным или их изменения
- Более гибкий и легко изменяемый код
- Возможность изменять одну часть кода, не затрагивая другие части

=====================================================================================
Inheritance - наследование

Наследование - это процесс, который позволяет одному классу приобретать свойства 
(методы и переменные) другого. При наследовании информация размещается в более 
управляемом иерархическом порядке.

Класс, наследующий свойства другого, является подклассом (также называемым 
производным классом или дочерним классом); класс, свойства которого наследуются, 
является суперклассом (базовым классом или родительским классом).

Чтобы наследовать от класса, используйте ключевое слово extends.
В этом примере показано, как заставить класс Dog наследоваться от класса Animal.

class Dog extends Animal {
 // some code
}

Здесь Dog - это подкласс, а Animal - суперкласс.

Когда один класс наследуется от другого класса, он наследует все непубличные 
переменные и методы суперкласса.
Пример:

class Animal {
  protected int legs;
  public void eat() {
    System.out.println("Animal eats");
  }
}

class Dog extends Animal {
  Dog() {
    legs = 4;
  }
}

Как вы можете видеть, класс Dog наследует переменную legs от класса Animal.
Теперь мы можем объявить объект Dog и вызвать метод eat его суперкласса:

class Animal {
    protected int legs;
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    Dog() {
        legs = 4;
    }
}

class MyClass {
    public static void main(String[ ] args) {
        Dog d = new Dog();
        d.eat();
    }
}

Вспомните модификатор защищенного доступа, который делает элементы видимыми 
только для подклассов.

Конструкторы не являются методами-членами и поэтому не наследуются подклассами.
Однако конструктор суперкласса вызывается при создании экземпляра подкласса.
Пример:

class A {
    public A() {
        System.out.println("New A");
    }
}
class B extends A {
    public B() {
        System.out.println("New B");
    }
}

class Program {
    public static void main(String[ ] args) {
        B obj = new B();
    }
}

Вы можете получить доступ к суперклассу из подкласса, используя ключевое слово super.
Например, super.var обращается к члену var суперкласса.

Частные методы не наследуются из суперкласса!!!

=====================================================================================
Polymorphism - полиморфизм

Полиморфизм, который относится к идее "наличия множества форм", возникает, когда 
существует иерархия классов, связанных друг с другом посредством наследования.
Вызов метода-члена приведет к выполнению другой реализации, в зависимости от типа 
объекта, вызывающего метод.

Вот пример: Dog и Cat - это классы, которые наследуются от класса Animal. Каждый 
класс имеет свою собственную реализацию метода makeSound().

class Animal {
  public void makeSound() {
    System.out.println("Grr...");
  }
}
class Cat extends Animal {
  public void makeSound() {
    System.out.println("Meow");
  }
}
class Dog extends Animal {
  public void makeSound() {
    System.out.println("Woof");
  }
}

Поскольку все объекты Cat и Dog являются объектами Animal, мы можем сделать 
следующее в основном:

public static void main(String[ ] args) {
  Animal a = new Dog();
  Animal b = new Cat();
}

Мы создали две ссылочные переменные типа Animal и указали им на объекты Cat и Dog.
Теперь мы можем вызвать методы makeSound().

class Animal {
    public void makeSound() {
        System.out.println("Grr...");
    }
}
class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}
class Dog extends Animal {
    public void makeSound() {
        System.out.println("Woof");
    }
}

class Program {
    public static void main(String args[ ]) {
        Animal a = new Dog();
        Animal b = new Cat();
        
        a.makeSound();
        b.makeSound();
    }
}

Поскольку ссылочная переменная a содержит объект Dog, будет вызван метод 
makeSound() класса Dog.
То же самое относится и к переменной b.

Это демонстрирует, что вы можете использовать переменную Animal, фактически 
не зная, что она содержит объект подкласса.
Это очень полезно, когда у вас есть несколько подклассов суперкласса.

=====================================================================================
Переопределение метода

Как мы видели в предыдущем уроке, подкласс может определять поведение, специфичное 
для типа подкласса, что означает, что подкласс может реализовать метод родительского 
класса на основе его требований.
Эта функция известна как переопределение метода.

Пример:

class Animal {
    public void makeSound() {
        System.out.println("Grr...");
    }
}
class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}

class Program {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.makeSound();
    }
}

В приведенном выше коде класс Cat переопределяет метод makeSound() своего суперкласса Animal.

Правила для переопределения методов:
- Должен иметь тот же возвращаемый тип и аргументы
- Уровень доступа не может быть более ограничительным, чем уровень доступа 
переопределенного метода (пример: если метод суперкласса объявлен общедоступным, 
переопределяющий метод в подклассе не может быть ни частным, ни защищенным)
- Метод, объявленный окончательным или статическим (final or static), 
не может быть переопределен
- Если метод не может быть унаследован, он не может быть переопределен
- Конструкторы не могут быть переопределены

Переопределение метода также известно как полиморфизм среды выполнения.

Когда методы имеют одно и то же имя, но разные параметры, это называется 
перегрузкой метода.
Это может быть очень полезно, когда вам нужна одна и та же функциональность 
метода для разных типов параметров.
Следующий пример иллюстрирует метод, который возвращает максимум из двух своих 
параметров.

int max(int a, int b) {
  if(a > b) {
    return a;
  }
  else {
    return b;
  }
}

Метод, показанный выше, будет работать только для параметров типа integer.
Однако, возможно, мы захотим использовать его и для парных игр. Для этого 
вам нужно перегрузить метод max:

class Program {
    static double max(double a, double b) {
        if(a > b) {
            return a;
        }
        else {
            return b;
        }
    }
    static int max(int a, int b) {
        if(a > b) {
            return a;
        }
        else {
            return b;
        }
    }
    public static void main(String[] args) {        
        System.out.println(max(8, 17));
        System.out.println(max(3.14, 7.68));
    }
}

Теперь наш метод max также будет работать с удвоениями.
Перегруженный метод должен иметь другой список аргументов; параметры должны 
отличаться по своему типу, номеру или и тому, и другому.

Другое название перегрузки метода - полиморфизм во время компиляции.

=====================================================================================
Абстракция

Абстракция данных предоставляет внешнему миру только необходимую информацию в 
процессе представления основных функций без включения деталей реализации.
Хорошим примером из реального мира является книга. Когда вы слышите термин 
"книга", вы не знаете точных особенностей, таких как количество страниц, цвет 
или размер, но вы понимаете идею или абстракцию книги.

Концепция абстракции заключается в том, что мы фокусируемся на существенных 
качествах, а не на конкретных характеристиках одного конкретного примера.

В Java абстракция достигается с помощью абстрактных классов и интерфейсов.
Абстрактный класс определяется с помощью ключевого слова abstract.
- Если класс объявлен абстрактным, он не может быть создан (вы не можете создавать 
объекты этого типа).
- Чтобы использовать абстрактный класс, вы должны наследовать его от другого класса.
- Любой класс, содержащий абстрактный метод, должен быть определен как абстрактный.

Абстрактный метод - это метод, который объявлен без реализации (без фигурных 
скобок, за которым следует точка с запятой): abstract void walk();

Например, мы можем определить наш класс Animal как абстрактный:

abstract class Animal {
  int legs = 0;
  abstract void makeSound();
}

Метод makeSound также является абстрактным, поскольку он не имеет реализации 
в суперклассе.
Мы можем наследовать от класса Animal и определить метод makeSound() для подкласса:

abstract class Animal {
    int legs = 0;
    abstract void makeSound();
}

class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}

public class Program {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.makeSound();
    }
}

Каждое животное издает звук, но у каждого есть свой способ сделать это. Вот почему 
мы определяем абстрактный класс Animal и оставляем реализацию того, как они издают 
звуки, подклассам.

Это используется, когда для метода в суперклассе нет значимого определения.


=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
