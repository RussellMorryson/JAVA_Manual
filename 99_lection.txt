
Когда вы объявляете переменную или метод как статические, они 
принадлежат классу, а не конкретному экземпляру. Это означает, 
что существует только один экземпляр статического члена, даже если 
вы создаете несколько объектов класса или не создаете ни одного. Он 
будет общим для всех объектов.
Пример:

public class Counter {
  public static int COUNT=0;
  Counter() {
    COUNT++;
  }
}

Переменная COUNT будет общей для всех объектов этого класса.
Теперь мы можем создавать объекты нашего класса Counter в main и 
получать доступ к статической переменной.

public class Counter {
    public static int COUNT=0;
    Counter() {
        COUNT++;
    }
}

public class MyClass {
    public static void main(String[ ] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        System.out.println(Counter.COUNT);
    }
}

Результат равен 2, потому что переменная COUNT является статической и 
увеличивается на единицу каждый раз, когда создается новый объект 
класса Counter. В приведенном выше коде мы создали 2 объекта.
Вы также можете получить доступ к статической переменной, используя 
любой объект этого класса, например c1.COUNT.
Обычной практикой является использование верхнего регистра при 
именовании статической переменной, хотя это и не обязательно.

Та же концепция применима и к статическим методам.

public class Vehicle {
  public static void horn() {
    System.out.println("Beep");
  }
}

Теперь метод horn может быть вызван без создания объекта:

public class Vehicle {
    public static void horn() {
        System.out.println("Beep");
    }
}

public class MyClass {
    public static void main(String[ ] args) {
        Vehicle.horn();
    }
}

Другим примером статических методов являются методы класса Math, 
поэтому вы можете вызывать их без создания математического объекта.
Кроме того, основной метод всегда должен быть статическим.

=====================================================================================
FINAL
Используйте ключевое слово final, чтобы пометить переменную константой, 
чтобы ее можно было назначить только один раз.
Пример:

class MyClass {
    public static final double PI = 3.14; 
    public static void main(String[ ] args) {
        System.out.println(PI);
    }
}

=====================================================================================
Пакеты
Пакеты используются для того, чтобы избежать конфликтов имен и 
контролировать доступ к классам.

Пакет может быть определен как группа, состоящая из аналогичных 
типов классов, наряду с подпакетами.

Создать пакет на Java довольно просто. Просто щелкните правой 
кнопкой мыши на вашем каталоге src и выберите Создать-> Пакет. 
Дайте вашему пакету имя и нажмите Готово.

Вы заметите, что новый пакет появится в каталоге проекта. Теперь 
вы можете перемещать и создавать классы внутри этого пакета. 
Мы перенесли наши классы транспортных средств, прилавков и 
животных в образцы упаковки.

Когда вы перемещаете/создаете класс в своем пакете, следующий 
код появится в верхней части списка файлов.

package samples;

Это указывает на пакет, к которому принадлежит класс.
Теперь нам нужно импортировать классы, которые находятся 
внутри пакета, в наш основной, чтобы иметь возможность их 
использовать.

В следующем примере показано, как использовать класс 
транспортного средства пакета samples.

import samples.Vehicle;

class MyClass {
  public static void main(String[ ] args) {
    Vehicle v1 = new Vehicle();
    v1.horn();
  }
}

Два основных результата возникают, когда класс 
помещается в пакет. Во-первых, имя пакета становится 
частью имени класса. Во-вторых, имя пакета должно 
соответствовать структуре каталогов, в которой 
находится соответствующий файл класса.

Используйте подстановочный знак для импорта всех классов в пакете.
Например, import samples.* импортирует все классы в пакете samples.

*****************************************************************************
"default" access in Java is "package-private", meaning that everything 
in the same package can access the attribute/method. So basically 
this should also be correct! Even "protected" (the missing level 
of accessibility) would the correct, even though it is not in the 
set of possible answers - it means "accessible from the same class 
and from all is subclasses", which is obviously more than "the same 
class".

доступ "по умолчанию" в Java - "package-private", что означает, 
что все в одном пакете могут получить доступ к атрибуту /методу. 
Так что в принципе это тоже должно быть правильно! 
Даже "защищенный" (отсутствующий уровень доступности) 
был бы правильным, даже если его нет в наборе возможных
ответов - это означает "доступный из того же класса и из 
всех подклассов is", что, очевидно, больше, чем "тот же класс".
************************************************************************
=====================================================================================
Encapsulation - инкапсуляция

В ООП существует 4 основных понятия: 
инкапсуляция, 
наследование, 
полиморфизм 
и абстракция.

Идея инкапсуляции заключается в том, чтобы гарантировать, что детали реализации 
не будут видны пользователям. Переменные одного класса будут скрыты от 
других классов, доступные только через методы текущего класса. 
Это называется скрытием данных.

Чтобы достичь инкапсуляции в Java, объявите переменные класса как 
частные и предоставьте общедоступные методы setter и getter для изменения 
и просмотра значений переменных.

Например:

class BankAccount {
  private double balance=0;
  public void deposit(double x) {
    if(x > 0) {
      balance += x;
    }
  }
}

Эта реализация скрывает переменную баланса, предоставляя доступ к 
ней только через метод депозита, который проверяет сумму, подлежащую 
внесению, перед изменением переменной.

Таким образом, инкапсуляция обеспечивает следующие преимущества:
- Контроль способа доступа к данным или их изменения
- Более гибкий и легко изменяемый код
- Возможность изменять одну часть кода, не затрагивая другие части

=====================================================================================
Inheritance - наследование

Наследование - это процесс, который позволяет одному классу приобретать свойства 
(методы и переменные) другого. При наследовании информация размещается в более 
управляемом иерархическом порядке.

Класс, наследующий свойства другого, является подклассом (также называемым 
производным классом или дочерним классом); класс, свойства которого наследуются, 
является суперклассом (базовым классом или родительским классом).

Чтобы наследовать от класса, используйте ключевое слово extends.
В этом примере показано, как заставить класс Dog наследоваться от класса Animal.

class Dog extends Animal {
 // some code
}

Здесь Dog - это подкласс, а Animal - суперкласс.

Когда один класс наследуется от другого класса, он наследует все непубличные 
переменные и методы суперкласса.
Пример:

class Animal {
  protected int legs;
  public void eat() {
    System.out.println("Animal eats");
  }
}

class Dog extends Animal {
  Dog() {
    legs = 4;
  }
}

Как вы можете видеть, класс Dog наследует переменную legs от класса Animal.
Теперь мы можем объявить объект Dog и вызвать метод eat его суперкласса:

class Animal {
    protected int legs;
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    Dog() {
        legs = 4;
    }
}

class MyClass {
    public static void main(String[ ] args) {
        Dog d = new Dog();
        d.eat();
    }
}

Вспомните модификатор защищенного доступа, который делает элементы видимыми 
только для подклассов.



=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================