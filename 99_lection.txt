
Когда вы объявляете переменную или метод как статические, они 
принадлежат классу, а не конкретному экземпляру. Это означает, 
что существует только один экземпляр статического члена, даже если 
вы создаете несколько объектов класса или не создаете ни одного. Он 
будет общим для всех объектов.
Пример:

public class Counter {
  public static int COUNT=0;
  Counter() {
    COUNT++;
  }
}

Переменная COUNT будет общей для всех объектов этого класса.
Теперь мы можем создавать объекты нашего класса Counter в main и 
получать доступ к статической переменной.

public class Counter {
    public static int COUNT=0;
    Counter() {
        COUNT++;
    }
}

public class MyClass {
    public static void main(String[ ] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        System.out.println(Counter.COUNT);
    }
}

Результат равен 2, потому что переменная COUNT является статической и 
увеличивается на единицу каждый раз, когда создается новый объект 
класса Counter. В приведенном выше коде мы создали 2 объекта.
Вы также можете получить доступ к статической переменной, используя 
любой объект этого класса, например c1.COUNT.
Обычной практикой является использование верхнего регистра при 
именовании статической переменной, хотя это и не обязательно.

Та же концепция применима и к статическим методам.

public class Vehicle {
  public static void horn() {
    System.out.println("Beep");
  }
}

Теперь метод horn может быть вызван без создания объекта:

public class Vehicle {
    public static void horn() {
        System.out.println("Beep");
    }
}

public class MyClass {
    public static void main(String[ ] args) {
        Vehicle.horn();
    }
}

Другим примером статических методов являются методы класса Math, 
поэтому вы можете вызывать их без создания математического объекта.
Кроме того, основной метод всегда должен быть статическим.

=====================================================================================
FINAL
Используйте ключевое слово final, чтобы пометить переменную константой, 
чтобы ее можно было назначить только один раз.
Пример:

class MyClass {
    public static final double PI = 3.14; 
    public static void main(String[ ] args) {
        System.out.println(PI);
    }
}

=====================================================================================
Пакеты
Пакеты используются для того, чтобы избежать конфликтов имен и 
контролировать доступ к классам.

Пакет может быть определен как группа, состоящая из аналогичных 
типов классов, наряду с подпакетами.

Создать пакет на Java довольно просто. Просто щелкните правой 
кнопкой мыши на вашем каталоге src и выберите Создать-> Пакет. 
Дайте вашему пакету имя и нажмите Готово.

Вы заметите, что новый пакет появится в каталоге проекта. Теперь 
вы можете перемещать и создавать классы внутри этого пакета. 
Мы перенесли наши классы транспортных средств, прилавков и 
животных в образцы упаковки.

Когда вы перемещаете/создаете класс в своем пакете, следующий 
код появится в верхней части списка файлов.

package samples;

Это указывает на пакет, к которому принадлежит класс.
Теперь нам нужно импортировать классы, которые находятся 
внутри пакета, в наш основной, чтобы иметь возможность их 
использовать.

В следующем примере показано, как использовать класс 
транспортного средства пакета samples.

import samples.Vehicle;

class MyClass {
  public static void main(String[ ] args) {
    Vehicle v1 = new Vehicle();
    v1.horn();
  }
}

Два основных результата возникают, когда класс 
помещается в пакет. Во-первых, имя пакета становится 
частью имени класса. Во-вторых, имя пакета должно 
соответствовать структуре каталогов, в которой 
находится соответствующий файл класса.

Используйте подстановочный знак для импорта всех классов в пакете.
Например, import samples.* импортирует все классы в пакете samples.

*****************************************************************************
"default" access in Java is "package-private", meaning that everything 
in the same package can access the attribute/method. So basically 
this should also be correct! Even "protected" (the missing level 
of accessibility) would the correct, even though it is not in the 
set of possible answers - it means "accessible from the same class 
and from all is subclasses", which is obviously more than "the same 
class".

доступ "по умолчанию" в Java - "package-private", что означает, 
что все в одном пакете могут получить доступ к атрибуту /методу. 
Так что в принципе это тоже должно быть правильно! 
Даже "защищенный" (отсутствующий уровень доступности) 
был бы правильным, даже если его нет в наборе возможных
ответов - это означает "доступный из того же класса и из 
всех подклассов is", что, очевидно, больше, чем "тот же класс".
************************************************************************
=====================================================================================
Encapsulation - инкапсуляция

В ООП существует 4 основных понятия: 
инкапсуляция, 
наследование, 
полиморфизм 
и абстракция.

Идея инкапсуляции заключается в том, чтобы гарантировать, что детали реализации 
не будут видны пользователям. Переменные одного класса будут скрыты от 
других классов, доступные только через методы текущего класса. 
Это называется скрытием данных.

Чтобы достичь инкапсуляции в Java, объявите переменные класса как 
частные и предоставьте общедоступные методы setter и getter для изменения 
и просмотра значений переменных.

Например:

class BankAccount {
  private double balance=0;
  public void deposit(double x) {
    if(x > 0) {
      balance += x;
    }
  }
}

Эта реализация скрывает переменную баланса, предоставляя доступ к 
ней только через метод депозита, который проверяет сумму, подлежащую 
внесению, перед изменением переменной.

Таким образом, инкапсуляция обеспечивает следующие преимущества:
- Контроль способа доступа к данным или их изменения
- Более гибкий и легко изменяемый код
- Возможность изменять одну часть кода, не затрагивая другие части

=====================================================================================
Inheritance - наследование

Наследование - это процесс, который позволяет одному классу приобретать свойства 
(методы и переменные) другого. При наследовании информация размещается в более 
управляемом иерархическом порядке.

Класс, наследующий свойства другого, является подклассом (также называемым 
производным классом или дочерним классом); класс, свойства которого наследуются, 
является суперклассом (базовым классом или родительским классом).

Чтобы наследовать от класса, используйте ключевое слово extends.
В этом примере показано, как заставить класс Dog наследоваться от класса Animal.

class Dog extends Animal {
 // some code
}

Здесь Dog - это подкласс, а Animal - суперкласс.

Когда один класс наследуется от другого класса, он наследует все непубличные 
переменные и методы суперкласса.
Пример:

class Animal {
  protected int legs;
  public void eat() {
    System.out.println("Animal eats");
  }
}

class Dog extends Animal {
  Dog() {
    legs = 4;
  }
}

Как вы можете видеть, класс Dog наследует переменную legs от класса Animal.
Теперь мы можем объявить объект Dog и вызвать метод eat его суперкласса:

class Animal {
    protected int legs;
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    Dog() {
        legs = 4;
    }
}

class MyClass {
    public static void main(String[ ] args) {
        Dog d = new Dog();
        d.eat();
    }
}

Вспомните модификатор защищенного доступа, который делает элементы видимыми 
только для подклассов.

Конструкторы не являются методами-членами и поэтому не наследуются подклассами.
Однако конструктор суперкласса вызывается при создании экземпляра подкласса.
Пример:

class A {
    public A() {
        System.out.println("New A");
    }
}
class B extends A {
    public B() {
        System.out.println("New B");
    }
}

class Program {
    public static void main(String[ ] args) {
        B obj = new B();
    }
}

Вы можете получить доступ к суперклассу из подкласса, используя ключевое слово super.
Например, super.var обращается к члену var суперкласса.

Частные методы не наследуются из суперкласса!!!

=====================================================================================
Polymorphism - полиморфизм

Полиморфизм, который относится к идее "наличия множества форм", возникает, когда 
существует иерархия классов, связанных друг с другом посредством наследования.
Вызов метода-члена приведет к выполнению другой реализации, в зависимости от типа 
объекта, вызывающего метод.

Вот пример: Dog и Cat - это классы, которые наследуются от класса Animal. Каждый 
класс имеет свою собственную реализацию метода makeSound().

class Animal {
  public void makeSound() {
    System.out.println("Grr...");
  }
}
class Cat extends Animal {
  public void makeSound() {
    System.out.println("Meow");
  }
}
class Dog extends Animal {
  public void makeSound() {
    System.out.println("Woof");
  }
}

Поскольку все объекты Cat и Dog являются объектами Animal, мы можем сделать 
следующее в основном:

public static void main(String[ ] args) {
  Animal a = new Dog();
  Animal b = new Cat();
}

Мы создали две ссылочные переменные типа Animal и указали им на объекты Cat и Dog.
Теперь мы можем вызвать методы makeSound().

class Animal {
    public void makeSound() {
        System.out.println("Grr...");
    }
}
class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}
class Dog extends Animal {
    public void makeSound() {
        System.out.println("Woof");
    }
}

class Program {
    public static void main(String args[ ]) {
        Animal a = new Dog();
        Animal b = new Cat();
        
        a.makeSound();
        b.makeSound();
    }
}

Поскольку ссылочная переменная a содержит объект Dog, будет вызван метод 
makeSound() класса Dog.
То же самое относится и к переменной b.

Это демонстрирует, что вы можете использовать переменную Animal, фактически 
не зная, что она содержит объект подкласса.
Это очень полезно, когда у вас есть несколько подклассов суперкласса.

=====================================================================================
Переопределение метода

Как мы видели в предыдущем уроке, подкласс может определять поведение, специфичное 
для типа подкласса, что означает, что подкласс может реализовать метод родительского 
класса на основе его требований.
Эта функция известна как переопределение метода.

Пример:

class Animal {
    public void makeSound() {
        System.out.println("Grr...");
    }
}
class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}

class Program {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.makeSound();
    }
}

В приведенном выше коде класс Cat переопределяет метод makeSound() своего суперкласса Animal.

Правила для переопределения методов:
- Должен иметь тот же возвращаемый тип и аргументы
- Уровень доступа не может быть более ограничительным, чем уровень доступа 
переопределенного метода (пример: если метод суперкласса объявлен общедоступным, 
переопределяющий метод в подклассе не может быть ни частным, ни защищенным)
- Метод, объявленный окончательным или статическим (final or static), 
не может быть переопределен
- Если метод не может быть унаследован, он не может быть переопределен
- Конструкторы не могут быть переопределены

Переопределение метода также известно как полиморфизм среды выполнения.

Когда методы имеют одно и то же имя, но разные параметры, это называется 
перегрузкой метода.
Это может быть очень полезно, когда вам нужна одна и та же функциональность 
метода для разных типов параметров.
Следующий пример иллюстрирует метод, который возвращает максимум из двух своих 
параметров.

int max(int a, int b) {
  if(a > b) {
    return a;
  }
  else {
    return b;
  }
}

Метод, показанный выше, будет работать только для параметров типа integer.
Однако, возможно, мы захотим использовать его и для парных игр. Для этого 
вам нужно перегрузить метод max:

class Program {
    static double max(double a, double b) {
        if(a > b) {
            return a;
        }
        else {
            return b;
        }
    }
    static int max(int a, int b) {
        if(a > b) {
            return a;
        }
        else {
            return b;
        }
    }
    public static void main(String[] args) {        
        System.out.println(max(8, 17));
        System.out.println(max(3.14, 7.68));
    }
}

Теперь наш метод max также будет работать с удвоениями.
Перегруженный метод должен иметь другой список аргументов; параметры должны 
отличаться по своему типу, номеру или и тому, и другому.

Другое название перегрузки метода - полиморфизм во время компиляции.

=====================================================================================
Абстракция

Абстракция данных предоставляет внешнему миру только необходимую информацию в 
процессе представления основных функций без включения деталей реализации.
Хорошим примером из реального мира является книга. Когда вы слышите термин 
"книга", вы не знаете точных особенностей, таких как количество страниц, цвет 
или размер, но вы понимаете идею или абстракцию книги.

Концепция абстракции заключается в том, что мы фокусируемся на существенных 
качествах, а не на конкретных характеристиках одного конкретного примера.

В Java абстракция достигается с помощью абстрактных классов и интерфейсов.
Абстрактный класс определяется с помощью ключевого слова abstract.
- Если класс объявлен абстрактным, он не может быть создан (вы не можете создавать 
объекты этого типа).
- Чтобы использовать абстрактный класс, вы должны наследовать его от другого класса.
- Любой класс, содержащий абстрактный метод, должен быть определен как абстрактный.

Абстрактный метод - это метод, который объявлен без реализации (без фигурных 
скобок, за которым следует точка с запятой): abstract void walk();

Например, мы можем определить наш класс Animal как абстрактный:

abstract class Animal {
  int legs = 0;
  abstract void makeSound();
}

Метод makeSound также является абстрактным, поскольку он не имеет реализации 
в суперклассе.
Мы можем наследовать от класса Animal и определить метод makeSound() для подкласса:

abstract class Animal {
    int legs = 0;
    abstract void makeSound();
}

class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}

public class Program {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.makeSound();
    }
}

Каждое животное издает звук, но у каждого есть свой способ сделать это. Вот почему 
мы определяем абстрактный класс Animal и оставляем реализацию того, как они издают 
звуки, подклассам.

Это используется, когда для метода в суперклассе нет значимого определения.


=====================================================================================
Интерфейс

Интерфейс - это полностью абстрактный класс, который содержит только абстрактные 
методы.
Некоторые спецификации для интерфейсов:
- Определяется с помощью ключевого слова interface.
- Может содержать только статические конечные переменные.
- Не может содержать конструктор, поскольку интерфейсы не могут быть созданы.
- Интерфейсы могут расширять другие интерфейсы.
- Класс может реализовывать любое количество интерфейсов.

Пример простого интерфейса:
interface Animal {
  public void eat();
  public void makeSound();
}

Интерфейсы обладают следующими свойствами:
- Интерфейс неявно абстрактен. Вам не нужно использовать ключевое слово abstract 
при объявлении интерфейса.
- Каждый метод в интерфейсе также неявно абстрактен, поэтому ключевое слово 
abstract не требуется.
- Методы в интерфейсе неявно являются общедоступными.

Класс может наследовать только от одного суперкласса, но может реализовывать 
несколько интерфейсов!

Используйте ключевое слово implements, чтобы использовать интерфейс с вашим классом.

interface Animal {
    public void eat();
    public void makeSound();
}

class Cat implements Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
    public void eat() {
        System.out.println("omnomnom");
    }
}

public class Program {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.eat();
    }
}

Когда вы реализуете интерфейс, вам необходимо переопределить все его методы.

=====================================================================================
Приведение к типу

Присвоение значения одного типа переменной другого типа известно как приведение 
к типу.

Чтобы привести значение к определенному типу, заключите тип в круглые скобки и 
расположите его перед значением.
Пример:
public class Program {
    public static void main(String[] args) {
        int a = (int) 3.14;
        System.out.println(a);
    }
}
Приведенный выше код преобразует значение 3.14 в целое число с 3 в качестве 
результирующего значения.
Другой пример:

public class Program {
    public static void main(String[] args) {
        double a = 42.571;
        int b = (int) a;
        System.out.println(b);
    }
}

Java поддерживает автоматическое приведение целых чисел к типу с плавающей 
запятой, поскольку нет потери точности.
С другой стороны, приведение типов является обязательным при присвоении значений 
с плавающей запятой целочисленным переменным.
=====================================================================================
Для классов существует два типа кастинга.

Восходящий поток

Вы можете привести экземпляр подкласса к его суперклассу.
Рассмотрим следующий пример, предполагая, что Cat является подклассом Animal.

Animal a = new Cat();

Java автоматически преобразовала переменную типа Cat в тип Animal.

Нисходящий поток

Преобразование объекта суперкласса в его подкласс называется понижающим 
преобразованием.
Пример:

Animal a = new Cat();
((Cat)a).makeSound();

При этом будет предпринята попытка привести переменную a к типу Cat и вызвать 
ее метод makeSound().

Почему повышающая передача выполняется автоматически, а понижающая - вручную? 
Что ж, апкастинг никогда не может потерпеть неудачу. Но если у вас есть группа 
разных животных и вы хотите свести их всех к кошке, то есть вероятность, что 
некоторые из этих животных на самом деле собаки, поэтому процесс завершится неудачей.

=====================================================================================
Анонимные классы

Анонимные классы - это способ расширения существующих классов "на лету".
Например, подумайте о том, чтобы иметь классовую машину:

class Machine {
  public void start() {
    System.out.println("Starting...");
  }
}

При создании объекта Machine мы можем изменить метод запуска "на лету".

class Machine {
    public void start() {
        System.out.println("Starting...");
    }
}

class Program {
    public static void main(String[ ] args) {
        Machine m = new Machine() {
            @Override public void start() {
                System.out.println("Wooooo");
            }
        };
        m.start();
    }
}

После вызова конструктора мы открыли фигурные скобки и переопределили 
реализацию метода start "на лету".

Аннотация @Override используется для облегчения понимания вашего кода, поскольку 
она делает его более очевидным при переопределении методов.

Модификация применима только к текущему объекту, а не к самому классу. 
Таким образом, если мы создадим другой объект этого класса, реализация метода 
start будет той, которая определена в классе.

class Machine {
    public void start() {
        System.out.println("Starting...");
    }
}

class Program {
    public static void main(String[ ] args) {
        Machine m1 = new Machine() {
            @Override public void start() {
                System.out.println("Wooooo");
            }
        };
        m1.start();
        Machine m2 = new Machine();
        m2.start();
    }
}

Wooooo
Starting...


=====================================================================================
Внутренние классы


Java поддерживает вложенные классы; класс может быть членом другого класса.
Создать внутренний класс довольно просто. Просто напишите класс внутри класса. 
В отличие от класса, внутренний класс может быть закрытым. Как только вы объявляете 
внутренний класс закрытым, к нему нельзя получить доступ из объекта вне класса.
Пример:

class Robot {
    int id;
    Robot(int i) {
        id = i;
        Brain b = new Brain();
        b.think();
    }

    private class Brain {
        public void think() {
            System.out.println(id + " is thinking");
        }
    }
}

public class Program {
    public static void main(String[] args) {
        Robot r = new Robot(1);
    }
}

У классного робота есть внутренний классовый мозг. Внутренний класс может получить 
доступ ко всем переменным-членам и методам своего внешнего класса, но к нему 
нельзя получить доступ из какого-либо внешнего класса.
=====================================================================================
Сравнение объектов

Помните, что когда вы создаете объекты, переменные хранят ссылки на объекты.
Итак, когда вы сравниваете объекты с помощью оператора проверки равенства (==), 
он фактически сравнивает ссылки, а не значения объекта.
Пример:

class Animal {
    String name;
    Animal(String n) {
        name = n;
    }
}

class MyClass {
    public static void main(String[ ] args) {
        Animal a1 = new Animal("Robby");
        Animal a2 = new Animal("Robby");
        System.out.println(a1 == a2);
    }
}

//false//

Несмотря на наличие двух объектов с одинаковым именем, проверка на равенство 
возвращает значение false, потому что у нас есть два разных объекта (две разные 
ссылки или ячейки памяти).

Каждый объект имеет предопределенный метод equals(), который используется для 
проверки семантического равенства.

Но, чтобы заставить его работать для наших классов, нам нужно переопределить его 
и проверить нужные нам условия.

Существует простой и быстрый способ сгенерировать метод equals(), отличный от 
написания его вручную.

Просто щелкните правой кнопкой мыши в вашем классе, перейдите в Source->Generate 
hashCode() и equals()...

Это автоматически создаст необходимые методы.

class Animal {
  String name;
  Animal(String n) {
    name = n;
  }
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
  }
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    Animal other = (Animal) obj;
    if (name == null) {
      if (other.name != null)
        return false;
    } else if (!name.equals(other.name))
      return false;
    return true;
  }
}

Автоматически сгенерированный метод hashCode() используется для определения 
места внутреннего хранения объекта. Всякий раз, когда вы реализуете equals, 
вы также должны реализовать hashCode.
Мы можем запустить тест снова, используя метод equals:

class Animal {
    String name;
    Animal(String n) {
        name = n;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Animal other = (Animal) obj;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        return true;
    }
}

class Program {
    public static void main(String[ ] args) {
        Animal a1 = new Animal("Robby");
        Animal a2 = new Animal("Robby");
        System.out.println(a1.equals(a2));
    }
}

//true //

Вы можете использовать то же меню для создания других полезных методов, таких как
 геттеры и сеттеры для атрибутов вашего класса.
=====================================================================================
Перечисление - это специальный тип, используемый для определения коллекций констант.
Вот простой пример перечисления:
enum Rank {
  SOLDIER,
  SERGEANT,
  CAPTAIN
}
Обратите внимание, что значения разделены запятыми.
Вы можете ссылаться на константы в приведенном выше перечислении с помощью 
синтаксиса dot.

Rank a = Rank.SOLDIER;
По сути, перечисления определяют переменные, которые представляют члены 
фиксированного набора.

После объявления перечисления мы можем проверить наличие соответствующих 
значений, например, с помощью инструкции switch.

public class Program {
    enum Rank {
        SOLDIER,
        SERGEANT,
        CAPTAIN
    }
    public static void main(String[] args) {
        Rank a = Rank.SOLDIER;
                
        switch(a) {
            case SOLDIER:
                System.out.println("Soldier says hi!");
                break;
            case SERGEANT:
                System.out.println("Sergeant says Hello!");
                break;
            case CAPTAIN:
                System.out.println("Captain says Welcome!");
                break;
        }
    }
}

Вы всегда должны использовать перечисления, когда переменная (особенно параметр 
метода) может принимать только одно из небольшого набора возможных значений.
Если вы используете перечисления вместо целых чисел (или строковых кодов), 
вы увеличиваете время проверки во время компиляции и избегаете ошибок при 
передаче недопустимых констант, а также документируете, какие значения допустимы 
для использования.

Некоторые примеры использования перечислений включают названия месяцев, дней недели, 
колоду карт и т.д.

=====================================================================================
Java API

Java API - это набор классов и интерфейсов, которые были написаны для вашего 
использования.
Документация Java API со всеми доступными API-интерфейсами может быть размещена 
на веб-сайте Oracle по адресу
http://docs.oracle.com/javase/7/docs/api/

Как только вы найдете пакет, который хотите использовать, вам нужно импортировать 
его в свой код.

Пакет можно импортировать, используя ключевое слово import.
Например:
import java.awt.*;

Пакет awt содержит все классы для создания пользовательских интерфейсов 
и для рисования графики и изображений.

Подстановочный знак (*) используется для импорта всех классов в пакете.
=====================================================================================
ИСКЛЮЧЕНИЯ

Исключение - это проблема, возникающая во время выполнения программы. Исключения 
приводят к аварийному завершению программы.
Обработка исключений - это мощный механизм, который обрабатывает ошибки во время 
выполнения для поддержания нормального потока приложений.

Исключение может возникнуть по многим разным причинам. Несколько примеров:
- Пользователь ввел неверные данные.
- Файл, который необходимо открыть, не может быть найден.
- Сетевое соединение было потеряно в середине обмена сообщениями.
- Недостаточная память и другие проблемы, связанные с физическими ресурсами.

Как вы можете видеть, исключения вызваны ошибкой пользователя, ошибкой программиста 
или проблемами с физическими ресурсами. Однако хорошо написанная программа должна 
обрабатывать все возможные исключения.

Исключения могут быть перехвачены с помощью комбинации ключевых слов try и catch.
Блок try/catch помещается вокруг кода, который может сгенерировать исключение.
Синтаксис:

try {
  //some code
} catch (Exception e) {
  //some code to handle errors
}

Оператор catch включает в себя объявление типа исключения, которое вы пытаетесь 
перехватить. Если в блоке try возникает исключение, проверяется блок catch, 
который следует за попыткой. Если тип возникшего исключения указан в блоке catch, 
исключение передается в блок catch так же, как аргумент передается в параметр метода.

Тип исключения может использоваться для перехвата всех возможных исключений.

Приведенный ниже пример демонстрирует обработку исключений при попытке получить 
доступ к индексу массива, который не существует:

public class MyClass {
    public static void main(String[ ] args) {
        try {
            int a[ ] = new int[2];
            System.out.println(a[5]);
        } catch (Exception e) {
            System.out.println("An error occurred");
        }
    }
}

Без блока try/catch этот код должен привести к сбою программы, так как a[5] 
не существует.
Обратите внимание на инструкцию (Exception e) в блоке catch - она используется 
для перехвата всех возможных исключений.

=====================================================================================

Ключевое слово throw позволяет вам вручную генерировать исключения из ваших методов. 
Некоторые из многочисленных доступных типов исключений включают исключение 
IndexOutOfBoundsException, исключение IllegalArgumentException, исключение 
ArithmeticException и так далее.
Например, мы можем вызвать исключение ArithmeticException в нашем методе, когда 
параметр равен 0.

public class Program {
    static int div(int a, int b) throws ArithmeticException {
        if(b == 0) {
            throw new ArithmeticException("Division by Zero");
        } else {
            return a / b;
        }
    }
    public static void main(String[] args) {
        System.out.println(div(42, 0));
    }
}

Оператор throws в определении метода определяет тип исключений, которые 
может выдавать метод.
Затем ключевое слово throw выдает соответствующее исключение вместе с 
пользовательским сообщением.

Если мы вызовем метод div со вторым параметром, равным 0, он выдаст 
ArithmeticException с сообщением "Деление на ноль".

Несколько исключений могут быть определены в инструкции throws с использованием 
списка, разделенного запятыми.

Один блок try может содержать несколько блоков catch, которые обрабатывают разные 
исключения отдельно.
Пример:
try {
  //some code
} catch (ExceptionType1 e1) {
  //Catch block
} catch (ExceptionType2 e2) {
  //Catch block
} catch (ExceptionType3 e3) {
  //Catch block
}

Все блоки catch должны быть упорядочены от наиболее специфичных к наиболее общим.
Следуя конкретным исключениям, вы можете использовать тип исключения для обработки 
всех других исключений в качестве последнего перехвата.

=====================================================================================
Java - это многопоточный язык программирования. Это означает, что наша программа 
может оптимально использовать доступные ресурсы, запустив два или более компонента 
одновременно, причем каждый компонент выполняет свою задачу.
Вы можете разделить определенные операции в рамках одного приложения на отдельные 
потоки, которые все выполняются параллельно.

Есть два способа создать поток.
1. Расширьте класс потоков
Наследуйте от класса Thread, переопределите его метод run() и запишите 
функциональность потока в метод run().
Затем вы создаете новый объект своего класса и вызываете его метод start для 
запуска потока.
Пример:

class Loader extends Thread {
    public void run() {
        System.out.println("Hello");
    }
}

class MyClass {
    public static void main(String[ ] args) {
        Loader obj = new Loader();
        obj.start();
    }
}

Как вы можете видеть, наш класс Loader расширяет класс Thread и переопределяет 
его метод run().
Когда мы создаем объект obj и вызываем его метод start(), инструкции метода run() 
выполняются в другом потоке.

Каждый поток Java имеет приоритет, чтобы помочь операционной системе определить 
порядок планирования потоков. Приоритеты варьируются от 1 до 10, причем каждый 
поток по умолчанию имеет приоритет 5. Вы можете установить приоритет потока с 
помощью метода setPriority().

Другим способом создания потоков является реализация интерфейса Runnable.
Реализуйте метод run(). Затем создайте новый объект Thread, передайте 
класс Runnable его конструктору и запустите поток, вызвав метод start().
Пример:
class Loader implements Runnable {
    public void run() {
        System.out.println("Hello");
    }
}

class MyClass {
    public static void main(String[ ] args) {
        Thread t = new Thread(new Loader());
        t.start();
    }
}

Метод Thread.sleep() приостанавливает поток на указанный период времени. 
Например, вызов Thread.sleep(1000); приостанавливает поток на одну секунду. 
Имейте в виду, что Thread.sleep() выдает исключение InterruptedException, 
поэтому обязательно окружите его блоком try/catch.

Может показаться, что реализация интерфейса Runnable немного сложнее, 
чем расширение из класса Thread. Однако реализация интерфейса Runnable является 
предпочтительным способом запуска потока, поскольку он также позволяет выполнять 
расширение из другого класса.


=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
=====================================================================================
